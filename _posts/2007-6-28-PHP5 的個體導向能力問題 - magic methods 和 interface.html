---
title: PHP5 的個體導向能力問題 - magic methods 和 interface
category: programming
old-category: PHP
tags: [php,spl,interface,magic method]
---
<div class="tags" style="display:none">Tags: php spl interface magic_method</div>
<p>
我這兩天和 racklin <a href="{{ site.baseurl }}/archives/2007/%E7%82%BA%E4%BB%80%E9%BA%BC%E9%82%84%E4%B8%8D%E5%8D%87%E7%B4%9APHP5.html#comment-11071499">討論 PHP 和 SPL 的內容</a>。經過這兩天的討論，我覺得我們愈來愈了解現在 PHP 語言的特性與未來發展方向的議題了。
</p>
<p>
我們的討論重點圍繞在 PHP5 的 magic method 與 interface 兩方面的內容。
</p>

<!--more-->
<p>
如果 PHP 沒有 magic method，那麼就要提供一個 interface 叫  <code>ObjectAccess</code> ，宣告兩個方法 __set, __get 。
</p>
<pre class="highlight"><code>class JsHash implements ObjectAccess, ArrayAccess {
  public function __set($k, $v) {
    $this-&gt;$k = $v;
  }
  public function __get($k) {
    return $this-&gt;$k;
  }

  public function offsetSet($k, $v) {
      $this-&gt;$k = $v;
  }
  public function offsetGet($k) {
    return $this-&gt;$k;
  }
}

$h = new JsHash;
$h-&gt;xyz = 'abc';
echo $h['xyz']
</code></pre>


<p>
反過來，如果 PHP 不用 interface <code>ArrayAccess</code>，而用 magic method ，那麼有一組 magic method: offsetSet, offsetGet。
</p>
<pre class="highlight"><code>class JsHash {
  public function __set($k, $v) {
    $this-&gt;$k = $v;
  }
  public function __get($k) {
    return $this-&gt;$k;
  }

  public function offsetSet($k, $v) {
      $this-&gt;$k = $v;
  }
  public function offsetGet($k) {
    return $this-&gt;$k;
  }
}

$h = new JsHash;
$h-&gt;xyz = 'abc';
echo $h['xyz']
</code></pre>


<p>
interface 是個空殼，類別實際上就是要有對應的 member method。
</p>

<p>
再回到 racklin 的<a href="{{ site.baseurl }}/archives/2007/%E7%82%BA%E4%BB%80%E9%BA%BC%E9%82%84%E4%B8%8D%E5%8D%87%E7%B4%9APHP5.html#comment-11071499">例子</a>:
</p>
<pre class="highlight"><code>function abc(ArrayAccess $obj) {
    echo $obj[0];
}

$a = array(0);
abc(new ArrayObject($a));
abc( $a ); //ERROR!
</code></pre>

<p>
這樣就限定 $obj 必須是一個集合型態的實例了。但第7行出現了一個很好笑的矛盾：原生的陣列竟然不被接受!? 對 C++ 使用者而言，這種情形表示程序員的功力不夠，竟然忘了覆載型別轉換運算子。
</p>
<p>
此一矛盾起因於 PHP 沒有把 primitive type 個體化，又沒有把 primitive type 的方法自動繫結到個體方法上。若 primitive array 個體化了，亦即 primitive array 是 Array 類的實例，也必然實作了 ArrayAccess interface ，第7行就不會發生錯誤。
</p>

<p>
再者，在 PHP 中不常這麼做，更常見的情形是引數可以是任何型態。<em>這種實作方式牽涉到 PHP5 不像 C++/Java 具有同名異式的覆載能力</em>。理由可見 <a href="{{ site.baseurl }}/archives/2007/%E5%8B%95%E6%85%8B%E8%AA%9E%E8%A8%80%E9%97%9C%E6%96%BC%E5%8F%83%E6%95%B8%E5%AE%A3%E5%91%8A%E7%9A%84%E5%AF%AB%E4%BD%9C%E9%A2%A8%E6%A0%BC.html">參數寫作風格</a>。對靜態語言而言，使用函數簽名按理來說是好的。但 PHP 目前不支援同名異式的覆載。這表示我如果想限定型別，就要增加許多不必要的方法名稱。例如: abcByArray(), abcByArrayAccess()。於是我們一般寫成:
</p>

<pre class="highlight"><code>function abc($obj) {
  // is_array() 不會檢查$obj是否實作了ArrayAccess。
  if (is_array($obj) or is_subclass_of($obj, 'ArrayAccess') /*method_exists($obj, 'offsetGet')*/)
  {
    foreach ($obj as $index =&gt; $v)
      echo $obj[$index];
  }
  else {
    echo $obj;
  }
}
</code></pre>

<p>
上例中也顯示 PHP 未平滑地將 primitive type 的方法(函數)與個體導向機制繫結，故 <code>is_array()</code> 只能判斷 primitive array ，而不能判別是否為一具有 ArrayAccess 行為的個體。
</p>
<p>
對compiler而言，interface幫助它在編譯程式碼的過程中檢查個體是否擁有所需的方法。但對 PHP 而言(它好歹算動態語言)，任何個體都有可能在執行後增刪方法。而且從最後一個例子可以看出，實際上我們還是<em>被迫</em>只關心 <var>$obj</var> 有沒有這個方法。注意， PHP 仍要求類別必須宣告它實作了 ArrayAccess ，PHP 才會將 <code>[ ]</code> 運算子繫結到 <code>offsetGet</code> 方法。
</p>
<p>
Ruby 的做法是，我只關注有沒有我需要的方法。使用者也可以隨時抽換他的方法內容。如下例:
</p>
<pre class="highlight"><code><span class="k">def</span> <span class="nf">abc</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="n">o</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
        <span class="nb">puts</span> <span class="n">i</span>
    <span class="p">}</span>
<span class="k">end</span>

<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">abc</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># if you want change the method of instance, just redefine it.</span>
<span class="k">def</span> <span class="nc">s</span><span class="o">.</span><span class="nf">each</span>
    <span class="k">yield</span> <span class="nb">self</span><span class="p">.</span><span class="nf">join</span>
<span class="k">end</span>
<span class="n">abc</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># like a string</span>

<span class="n">s</span> <span class="o">=</span> <span class="s1">'hello'</span>
<span class="n">abc</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="k">def</span> <span class="nc">s</span><span class="o">.</span><span class="nf">each</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">''</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
        <span class="k">yield</span> <span class="n">c</span>
    <span class="p">}</span>
<span class="k">end</span>
<span class="n">abc</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># like a array</span>
</code></pre>


<p>
正如 racklin 所說，每種語言都有自己的特性。不過從我上述的例子來看， PHP 似乎得了雙重人格症，而且兩邊的角色都沒有高水準的演出。
</p>
<p>
當然，基於我個人主觀意識，並不希望看到這種情形繼續下去。
</p><div class="note">樂多舊網址: <a href="http://blog.roodo.com/rocksaying/archives/3547207.html">http://blog.roodo.com/rocksaying/archives/3547207.html</a></div>